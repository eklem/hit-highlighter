{"version":3,"sources":["webpack://highlight/./index.js","webpack://highlight/webpack/bootstrap","webpack://highlight/webpack/startup"],"names":["defaultProperties","itemMaxWords","truncateStart","truncateEnd","hitPaddingMin","highlightStart","highlightEnd","divider","setPaddingStartEnd","hitArr","itemArrLength","properties","i","length","paddStart","Math","max","index","paddEnd","min","joinOverlappingPadding","console","log","splice","JSON","stringify","truncateHitArr","itemArr","hitTruncatedArr","slice","getTruncatedHighlightedString","hitTruncated","singleHitPadded","j","word","module","exports","queryArr","cases","hitCount","truncate","keepAllQueryWords","toLittlePadding","itemHighlighted","caseTruncate","map","itemWord","highlightable","addHighlighting","joinNeighbourHighlightable","wordObj","find","queryWord","setHighlightables","filter","caseKeepAllQueryWords","hitLength","itemLength","floor","expandPaddingMin","totalWords","wordsPerHit","wordsToMany","hitsToKeep","ceil","cutOffHitArray","hitFull","getHighlightedString","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"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","file":"hit-highlighter.js","sourcesContent":["const defaultProperties = {\n  itemMaxWords: 0,\n  truncateStart: '<span class=\"truncated\">',\n  truncateEnd: '</span>',\n  hitPaddingMin: 5,\n  highlightStart: '<span class=\"hitHighlight\">',\n  highlightEnd: '</span>',\n  divider: ' '\n}\n\nconst highlight = function (queryArr, itemArr, properties) {\n  properties = {\n    ...defaultProperties,\n    ...properties\n  }\n\n  const cases = {\n    hitCount: 0,\n    truncate: false,\n    keepAllQueryWords: true,\n    toLittlePadding: false\n  }\n\n  let hitArr = []\n  let hitTruncatedArr = []\n  let itemHighlighted = ''\n\n  // ### Preparing & preprocessing for hit highlighting ###\n  // A: Check if item is to be truncated\n  cases.truncate = caseTruncate(itemArr.length, properties)\n\n  // B: Set matched words to highlightable (true) in itemArr\n  itemArr = setHighlightables(itemArr, queryArr, cases)\n\n  // C: Joining neighbour highlightable words, removing redundant and setting index value\n  //    And add highlight start and end\n  itemArr = joinNeighbourHighlightable(itemArr, properties)\n  itemArr = addHighlighting(itemArr, properties)\n\n  // D: Defining index on highlightable words and pushing to hitArr\n  hitArr = itemArr.filter(itemArr => itemArr.highlightable)\n\n  // E: Check if to keep all query wordsCut off hit array\n  cases.keepAllQueryWords = caseKeepAllQueryWords(hitArr, properties)\n\n  // ### The highlighter \"switch\" ###\n  if (!cases.truncate) {\n    // just return the highlighted itemArray\n    console.log('### Case - Just highlight ###')\n    itemHighlighted = getHighlightedString(itemArr, properties.divider)\n    return itemHighlighted\n  } else if (cases.truncate && cases.keepAllQueryWords) {\n    // needs truncating, but keep all query words\n    console.log('### Case - Truncat but keep all query word hits ###')\n    properties.hitPaddingMin = properties.hitPaddingMin + expandPaddingMin(hitArr.length, itemArr.length, properties)\n    hitArr = setPaddingStartEnd(hitArr, itemArr.length, properties)\n    hitArr = joinOverlappingPadding(hitArr)\n    hitTruncatedArr = truncateHitArr(hitArr, itemArr, hitTruncatedArr)\n    itemHighlighted = getTruncatedHighlightedString(hitTruncatedArr, properties.truncateStart, properties.truncateEnd, properties.divider)\n    return itemHighlighted\n  } else if (cases.truncate && !cases.keepAllQueryWords) {\n    // needs truncadting and have to cut off query wors\n    console.log('### Case - Truncat and cut off some query word hits ###')\n    hitArr = cutOffHitArray(hitArr, properties)\n    hitArr = setPaddingStartEnd(hitArr, itemArr.length, properties)\n    hitArr = joinOverlappingPadding(hitArr)\n    hitTruncatedArr = truncateHitArr(hitArr, itemArr, hitTruncatedArr)\n    itemHighlighted = getTruncatedHighlightedString(hitTruncatedArr, properties.truncateStart, properties.truncateEnd, properties.divider)\n    return itemHighlighted\n  }\n}\n\n// ###################################\n// # The Functions to make it happen #\n// ###################################\n\n// Function: figure out if itemArr needs to be truncated\nconst caseTruncate = function (itemArrLength, properties, cases) {\n  if (itemArrLength > properties.itemMaxWords && properties.itemMaxWords !== 0) {\n    return true\n  } else {\n    return false\n  }\n}\n\n// Function: Set highlightable query words and count how many\nconst setHighlightables = function (itemArr, queryArr, cases) {\n  itemArr = itemArr.map(function (itemWord, index) {\n    const wordObj = {\n      word: itemWord\n    }\n    if (queryArr.find(function (queryWord) { return itemWord === queryWord })) {\n      wordObj.highlightable = true\n      cases.hitCount = cases.hitCount + 1\n    }\n    return wordObj\n  })\n  return itemArr\n}\n\n// Function: Joining neighbour highlightable words, removing redundant and setting index value\nconst joinNeighbourHighlightable = function (itemArr, properties) {\n  for (let i = 0; i < itemArr.length; i++) {\n    if (i > 0 && itemArr[i].highlightable && itemArr[i - 1].highlightable) {\n      // Joining this and previous word\n      itemArr[i].word = itemArr[i - 1].word + properties.divider + itemArr[i].word\n      // Removing previous word from array\n      itemArr.splice(i - 1, 1)\n      // fixing array count\n      i = i - 1\n    }\n    // setting index on all highlightable\n    if (itemArr[i].highlightable) {\n      itemArr[i].index = i\n    }\n  }\n  return itemArr\n}\n\n// Function: Add highlighting start and end to highlightable\nconst addHighlighting = function (itemArr, properties) {\n  itemArr = itemArr.map(function (itemWord, index) {\n    if (itemWord.highlightable) {\n      itemWord.word = properties.highlightStart + itemWord.word + properties.highlightEnd\n    }\n    return itemWord\n  })\n  return itemArr\n}\n\n// Just set index for padding start and end for each hit\nconst setPaddingStartEnd = function (hitArr, itemArrLength, properties) {\n  for (let i = 0; i < hitArr.length; i++) {\n    // do some padding stuff...\n    // console.log('hitArr before ' + i)\n    // console.log(hitArr)\n    hitArr[i].paddStart = Math.max(hitArr[i].index - properties.hitPaddingMin, 0)\n    hitArr[i].paddEnd = Math.min(hitArr[i].index + properties.hitPaddingMin + 1, itemArrLength)\n    // console.log('hitArr after ' + i)\n    // console.log(hitArr)\n  }\n  return hitArr\n}\n\n// Check if not to keep all query word hits\nconst caseKeepAllQueryWords = function (hitArr, properties) {\n  if (hitArr.length * ((properties.hitPaddingMin * 2) + 1) > properties.itemMaxWords) {\n    return false\n  } else {\n    return true\n  }\n}\n\n// Cut off hit array\nconst cutOffHitArray = function (hitArr, properties) {\n  // per hit\n  const totalWords = hitArr.length * ((properties.hitPaddingMin * 2) + 1)\n  const wordsPerHit = (properties.hitPaddingMin * 2) + 1\n  const wordsToMany = totalWords - properties.itemMaxWords\n  //  how many hits to cut off\n  const hitsToKeep = hitArr.length - (Math.ceil(wordsToMany / wordsPerHit))\n  hitArr = hitArr.slice(0, hitsToKeep)\n  return hitArr\n}\n\nconst expandPaddingMin = function (hitLength, itemLength, properties) {\n  return Math.floor((properties.itemMaxWords - ((hitLength * (properties.hitPaddingMin * 2)) + 1)) / hitLength / 2)\n}\n\nconst joinOverlappingPadding = function (hitArr) {\n  for (let i = 0; i < hitArr.length; i++) {\n    if (i > 0 && hitArr[i].paddStart <= hitArr[i - 1].paddEnd) {\n      // join this and previous\n      hitArr[i].paddStart = hitArr[i - 1].paddStart\n      console.log('Debugging joinOverlappingPadding')\n      console.log(hitArr[i])\n      console.log('hitArr.paddStart : ' + hitArr[i].paddStart)\n      console.log('hitArr.paddEnd   : ' + hitArr[i].paddEnd)\n      // Removing previous padding group from index\n      hitArr.splice(i - 1, 1)\n      // fixing array count\n      i = i - 1\n    }\n  }\n  console.log(JSON.stringify(hitArr))\n  return hitArr\n}\n\n// Generate Truncate groups\nconst truncateHitArr = function (hitArr, itemArr, hitTruncatedArr) {\n  for (let i = 0; i < hitArr.length; i++) {\n    hitTruncatedArr[i] = itemArr.slice(hitArr[i].paddStart, hitArr[i].paddEnd)\n  }\n  return hitTruncatedArr\n}\n\n// Join words + divider for highlighted full itemArr\nconst getHighlightedString = function (itemArr, divider) {\n  let hitFull = ''\n  for (let i = 0; i < itemArr.length; i++) {\n    hitFull += itemArr[i].word + divider\n  }\n  return hitFull\n}\n\n// Create the string with hit highligted, truncated and padded\n// Guessing this may need to have it's siblings for not truncated ???\nconst getTruncatedHighlightedString = function (hitTruncatedArr, truncateStart, truncateEnd, divider) {\n  let hitTruncated = []\n  for (let i = 0; i < hitTruncatedArr.length; i++) {\n    let singleHitPadded = ''\n    for (let j = 0; j < hitTruncatedArr[i].length; j++) {\n      singleHitPadded += hitTruncatedArr[i][j].word + divider\n    }\n    hitTruncated += truncateStart + singleHitPadded + truncateEnd\n  }\n  return hitTruncated\n}\n\nmodule.exports = highlight\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(10);\n"],"sourceRoot":""}